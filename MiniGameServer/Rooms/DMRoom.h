#pragma once
#include <mutex>
#include <map>
#include <set>
#include <DirectXCollision.h>
#include <atomic>
#include <vector>
#include <random>
#include "..\Common\PacketVector.h"
#include "..\LockFreeQueue.h"
#include "..\Character.h"
#include "..\protocol.h"

class User;

struct MoveDirInfo
{
	UID uid;
	float x;
	float y;

	MoveDirInfo(UID uid, float x, float y) : uid(uid), x(x), y(y) {};
};

/**
룸
실제 게임이 이뤄지는 객체

GameLogic (종료체크도 시행)
SendGameState (게임 상태 전송)

게임 종료 시 룸매니저로 회수 요청하는 로직으로 구성

*/
constexpr float MAP_WIDTH = 1000.0f;
constexpr float MAP_HEIGHT = 1000.0f;
class DMRoom : public LockFreeQueue
{
	friend Character;

public:
	DMRoom();
	virtual ~DMRoom();

	void SetQueueType(QueueType queType);

	void Init();							//Not Thread-Safe, RoomManager에서만 호출할 것.
	void Regist(std::vector<User*> users);	//Not Thread-Safe, RoomManager에서만 호출할 것.
	bool IsEnd() { return isEnd; };

protected:
	virtual void ProcessJob(Job job) override;

private:
	void GameLogic();
	void SendGameState();
	bool EndCheck();
	void QuitAllUser();

	void Disconnect(User* user);
	void End();
	void Update();

	//기본 방 운영 정보
	static constexpr long long UPDATE_INTERVAL = 20;					//업데이트 간격
	std::chrono::high_resolution_clock::time_point currentUpdateTime;	//deltaTime 측정용
	std::chrono::high_resolution_clock::time_point lastUpdateTime;		//상동

	PacketVector eventData; //전송될 이벤트 패킷(플레이어 힛, 리스폰 등)
	PacketVector infoData;  //전송될 위치정보 패킷
	bool isEnd{false};		//게임이 끝났는가?
	float deltaTime{};		//매 틱 변한 시간
	static constexpr float DEFAULT_MATCH_TIME = 180.0f;
	float leftTime{ DEFAULT_MATCH_TIME };		//남은 게임 시간

	
	

	//실제 게임 처리
	void ProcessAttack(UID uid);
	void ProcessMoveDir(MoveDirInfo* info);

	void UpdateLeftTime();
	void UpdatePosition();
	void UpdateCollider();
	bool CheckCollider(const Collider& a, const Collider& b);

	std::vector<Character> characterList{};	//플레이하는 '캐릭터' 컨테이너
	std::vector<User*> userList{};			//플레이중인 '유저' 컨테이너

	Collider mapCollider{MAP_WIDTH, MAP_HEIGHT, {0, 0, 0} };	//맵의 충돌객체, 낙사 판정 시 사용
	std::mt19937_64 randomEngine;
	std::uniform_real_distribution<float> randomRange{-1.0f, 1.0f};
};